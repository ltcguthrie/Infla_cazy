### Display only the first 3 rows of the Pima.te dataset using the head command
head(Pima.te, 3)
### Display only the last 4 rows of the Pima.te dataset using the tail command
tail(Pima.te, 4)
###Lets look at all of the different variables that are in this dataset
names(Pima.te)
### Identify a categorical variable. Is it nominal or ordinal?
## We can use the table function to see how many times a categorical variable shows up.
table(Pima.te$type)
### Identify a continuous variable.
### The structure function
str(Pima.te)
###3 steps to summarize data
####1) classify data type 2) use appropriate  numerical summaries 3) use appropriate visual summaries
#Summarizing Discrete variables
### Discrete data are summarized using *frquencies statistics*
#absolute
#relatice
#commulative
## we have a discrete variable type. We can use the ftable() function to get the absolute frequencies of the two types.
##Lets look at the frequencies of yes and no  and then assign the output to a new variable.
### A useful feature of R and other programming languages is that you can create new variables from exsisting data. This enables you
### to avoid unecessary repetition.
##For example, add any 2 numbers in R (3 + 8).
3 + 8
##Say I want to know what 3 + 8 + 4 sums to and then I want to know what 3 + 8 + 9 and 3 + 8 + 6. Instead of typing 3 + 8 multiple times,
## I can do the following:
## I can create a new variable that stores the result of 3 + 8 ny using the assignment operator, which is just a 'less than' symbol followed by a 'minus' sign.
a <- 3 + 8
a + 4
a + 9
a + 6
p <- (ftable(Pima.te$type))
### BMI can often be reported as a discrete variable with the following categories
##underweight
##normal
##overweight
##obese
##sometimes you will want to recode your data.Let's convert BMI to  an ordinal variable.
##A for loop is used to apply the same function calls to a collection of objects
### if...else statement
x <- -5
if(x > 0){
print("Non-negative number")
} else {
print("Negative number")
}
## Nested if...else statement
x <- 0
if (x < 0) {
print("Negative number")
} else if (x > 0) {
print("Positive number")
} else
print("Zero")
### use
Pima.te$new.bmi <- NULL
for (k in count) {
if (Pima.te$bmi[k] < 18.5){
Pima.te$new.bmi[k] = "underweight"
} else if (Pima.te$bmi[k] > 18.5 & Pima.te$bmi[k] < 24.9){
Pima.te$new.bmi[k] = "normal"
}else if (Pima.te$bmi[k] > 24.9 & Pima.te$bmi[k] < 29.9){
Pima.te$new.bmi[k] = "overweight"
}else if (Pima.te$bmi[k] >= 30){
Pima.te$new.bmi[k] = "obese"
}
}
head(Pima.te)
## absolute, relative and cummulative statistics
library (abd)
x <- (Pima.te$new.bmi)
x <- (Pima.te$new.bmi)
x <- factor (x, levels = c ("normal", "overweight", "obese"))
bmi.freqs <- cbind( Freq=table(x), Cumul=cumsum(table(x)), relative=prop.table(table(x)))
bmi.freqs <- data.frame (bmi.freqs)
cumrelfreq <- bmi.freqs$Cumul / nrow(Pima.te)
bmi.freqs <- cbind (bmi.freqs, cumrelfreq)
bmi.freqs$relative <- round (bmi.freqs$relative, digits = 2)
levels <- c ("normal", "overweight", "obese")
bmi.freqs <- cbind.data.frame (levels, bmi.freqs)
bmi.freqs$levels <- factor (bmi.freqs$levels, levels = c("normal", "overweight", "obese"))
#str (my.freqs)
colnames (bmi.freqs) <- c("BMI Level","Count", "Cumulative Sum","Relative Frequency", "Cumulative Frequency")
bmi.freqs
###Visualize
colnames (bmi.freqs) <- c ("levels", "count","sum", "rel", "cum")
bmi.freqs <- data.frame (bmi.freqs)
bmi.freqs$levels <- factor (bmi.freqs$levels, levels = c ("normal", "overweight", "obese"))
abs <- ggplot (bmi.freqs, aes (levels, color = levels,fill = levels,count )) + geom_bar(stat = "identity", width = 0.5)  + scale_y_continuous( expand = c(0, 0), limits = c(0,400)) + ggtitle ("Absolute Frequency")+ theme_igray() + theme (legend.position = "none")+ ylab ("") + xlab("")
rel <- ggplot (bmi.freqs, aes (levels, color = levels,fill = levels,rel )) + geom_bar(stat = "identity", width = 0.5) + scale_y_continuous( expand = c(0, 0), limits = c(0,.9)) + ggtitle ("Relative Frequency") + theme_igray()+ theme (legend.position = "none")+ ylab ("") + xlab("")
cum <- ggplot (bmi.freqs, aes (count)) + stat_ecdf() + ylab ("Cumulative Frequency") + xlab ("Levels") + geom_point (aes(x=count, y = cum, color = levels)) + ggtitle ("Cumulative Frequency") + theme_igray()+ theme (legend.position = "none") + ylab ("") + xlab("")
blank <- ggplot()
grid.arrange (abs, rel, cum, nrow = 3, heights = c(1,1,1))
#Summarizing Continuous Variables with two major types of measures
###1) center/location statistics -- measures of the center of the data
##mean
mean(Pima.te$bmi)
##median
median(Pima.te$bmi)
##mode
## R does not have a mode function so lets create one and call it findmode.
findmode <- function(v) {
ux <-unique(v)
ux[which.max(tabulate(match(v, ux)))]
}
findmode(Pima.te$bmi)
### Visualize
ggplot(Pima.te, aes(x=bmi)) +
geom_density(aes(x = bmi, y=..count..), colour="lightskyblue", fill="lightskyblue", alpha = 0.5) + theme_igray() + xlab("BMI") +
scale_y_continuous (expand = c(0,0))+
geom_vline(aes(xintercept=mean(bmi, na.rm=T)),
color="red3", linetype="solid", size=1)  +
geom_vline(aes(xintercept=median(bmi, na.rm=T)),
color="navy", linetype="dashed", size=1)+
geom_vline(aes(xintercept=findmode(bmi)),
color="green3", linetype="dashed", size=1)
##quantiles
##Quantiles are cutpoints that divide the observations in a sample in the same way. There is one less quantile than the number of groups created.
bmi_quants <- quantile (Pima.te$bmi, type = 4)
bmi_quants
###One advantage of dividing our data into quartiles is the we can calculate the interquartile range (IQR) . The IQR is the difference between the upper (Q3) and lower quartile (Q1) and it is also called the midspread or middle fifty → IQR = Q3 − Q1
###The IQR for our example data set is:
print ("The IQR for the BMI is")
IQR(Pima.te$bmi)
index <- seq (1:nrow(Pima.te))
Pima.te2 <- cbind (Pima.te, index)
first <- data.frame (subset(Pima.te, bmi <=28.1))
ggplot(Pima.te2, aes(x=index, y = bmi, size = bmi)) + geom_point(color = "orange", alpha = 0.5) + theme_igray() + xlab ("") + ylab ("") +
geom_hline (yintercept = 28.1, color = "navy",linetype ="dashed") + geom_hline (yintercept = 32.9,color = "red",linetype ="dashed") + geom_hline (yintercept = 37.2,color = "red3",linetype ="dashed") +
ggtitle ("BMI Values at each Quartile")
###2) dispersion/spread -- measures of the spread of the data - [provides information about the variability of the data]
##range: he difference between the maximum and minimum observed values: that is, range(x)=maximum(x)−minimum(x). Note that the range is a single value.
##variance: the average of squared deviations from the mean. It cannot be negative.
##standard deviation:  the square root of the variance.The standard deviation may be regarded as the average deviation from the mean. If all observed values are similar, the standard deviation (and variance) will be lower than if the values are more spread out.
##interquartile range
ranges <- c (max(Pima.te$age)-min(Pima.te$age),max(Pima.te$bmi)-min(Pima.te$bmi) )
vars <- c (var(Pima.te$age), var(Pima.te$bmi))
sds <- c (sd(Pima.te$age), sd(Pima.te$bmi))
iqrs <- c (IQR(Pima.te$age), IQR(Pima.te$bmi))
disp <- rbind.data.frame (vars, sds, iqrs, ranges)
colnames (disp) <- c ("AGE", "BMI")
rownames (disp) <- c ("Variance", "Standard Deviation", "IQR", "Range")
disp
####Since it is a categorical/factor variable, we can see how many times each value actually occurs in the data.
table(Pima.te$type)
### R has functions for getting all of the descriptive summary data
summary(Pima.te)
ls()
rm(list = ls())
ls()
library(ggthemes)
library(ggplot2)
library (gridExtra)
library(MASS)
Pima.te
?str
## Welcome to RStudio!!!
## Step One: Install all the packages that we need.
## Step Two: Load all the libraries that we will use.
## Step Three: Let's Go!!!
###installing packages
install.packages("ggthemes")
install.packages("ggplot2")
install.packages("ggthemes")
install.packages("gridExtra")
###loading packages
library(ggthemes)
library(ggplot2)
library (gridExtra)
library(MASS)
###Looking at Data
###Type ls() to list the variables in your workspace
##R has built in datasets. We are going to use a dataset called Pima.te. Type Pima.te and then check your console.
Pima.te
### It's very common for data to be stored in a data frame. It is the default class for data read into R using
### functions like read.csv() and read.table(), which you'll learn about in another lesson. Type class(Pima.te).
class(Pima.te)
##Type dim(Pima.te) This is a function that will tell us how many row and columns we have. Use the dim()
### to figure out how to use the dim function to know how many rows and columns we are dealing with
dim(Pima.te)
## The first number you see is the numbe of rows (observations) and the second number is the number of columns (variables).
##There are also functions to look at just rows or just columns.
nrow(Pima.te)
ncol(Pima.te)
### How big is this data set?
##[more-info] Brief explanation of bytes and memory, small data and big data.
object.size(Pima.te)
## To preview the data use the head() by typing head(Pima.te). By default, head() shows you the first six rows of the data.
head(Pima.te)
## Now use the tail command tail() to see the last six rows of the data.
tail(Pima.te)
### When you are not sure of how a command should work use a question mark (?).
?head
### Display only the first 3 rows of the Pima.te dataset using the head command. Use the help option to figure out how to do this.
#[hidden]
head(Pima.te, 3)
### Display only the last 4 rows of the Pima.te dataset using the tail command.
#[hidden]
tail(Pima.te, 4)
###Lets look at all of the different variables that are in this dataset
names(Pima.te)
### Identify a categorical variable. Is it nominal or ordinal?
## We can use the table function to see how many times a categorical variable shows up.
table(Pima.te$type)
### Identify a continuous variable.
### The structure function
str(Pima.te)
###3 steps to summarize data
#### [more-info]1) classify data type 2) use appropriate  numerical summaries 3) use appropriate visual summaries
#Summarizing Discrete variables
### [more-info]Discrete data are summarized using *frquencies statistics*
#absolute
#relative
#cummulative
## We have a discrete variable type. We can use the ftable() function to get the absolute frequencies of the two types.
##Lets look at the frequencies of yes and no  and then assign the output to a new variable.
### A useful feature of R and other programming languages is that you can create new variables from exsisting data. This enables you
### to avoid unecessary repetition.
##For example, add any 2 numbers in R. For example, I'm going to add 3 + 8.
3 + 8
##Say I want to know what 3 + 8 + 4 sums to and then I want to know what 3 + 8 + 9 and 3 + 8 + 6. Instead of typing 3 + 8 multiple times,
## I can do the following:
## I can create a new variable that stores the result of 3 + 8 by using the assignment operator, which is just a 'less than' symbol followed by a 'minus' sign.
a <- 3 + 8
a + 4
a + 9
a + 6
## Assign the frequency table to a new value called p.
##[more-info]
p <- (ftable(Pima.te$type))
### BMI can often be reported as a discrete variable with the following categories
##underweight
##normal
##overweight
##obese
##sometimes you will want to recode your data.Let's convert BMI to  an ordinal variable. We will do this using a for loop and if ...else statements.
##[more-info]A for loop is used to apply the same function calls to a collection of objects
### if...else statement
x <- -5
if(x > 0){
print("Non-negative number")
} else {
print("Negative number")
}
## Nested if...else statement
x <- 0
if (x < 0) {
print("Negative number")
} else if (x > 0) {
print("Positive number")
} else
print("Zero")
### use
Pima.te$new.bmi <- NULL
for (k in count) {
if (Pima.te$bmi[k] < 18.5){
Pima.te$new.bmi[k] = "underweight"
} else if (Pima.te$bmi[k] > 18.5 & Pima.te$bmi[k] < 24.9){
Pima.te$new.bmi[k] = "normal"
}else if (Pima.te$bmi[k] > 24.9 & Pima.te$bmi[k] < 29.9){
Pima.te$new.bmi[k] = "overweight"
}else if (Pima.te$bmi[k] >= 30){
Pima.te$new.bmi[k] = "obese"
}
}
head(Pima.te)
### Look at your data frame. Is anyone underweight?
## Now we will calculate absolute, relative and cummulative statistics
x <- (Pima.te$new.bmi)
x <- factor (x, levels = c ("normal", "overweight", "obese"))
bmi.freqs <- cbind( Freq=table(x), Cumul=cumsum(table(x)), relative=prop.table(table(x)))
bmi.freqs <- data.frame (bmi.freqs)
cumrelfreq <- bmi.freqs$Cumul / nrow(Pima.te)
bmi.freqs <- cbind (bmi.freqs, cumrelfreq)
bmi.freqs$relative <- round (bmi.freqs$relative, digits = 2)
levels <- c ("normal", "overweight", "obese")
bmi.freqs <- cbind.data.frame (levels, bmi.freqs)
bmi.freqs$levels <- factor (bmi.freqs$levels, levels = c("normal", "overweight", "obese"))
#str (my.freqs)
colnames (bmi.freqs) <- c("BMI Level","Count", "Cumulative Sum","Relative Frequency", "Cumulative Frequency")
bmi.freqs
###Visualize
colnames (bmi.freqs) <- c ("levels", "count","sum", "rel", "cum")
bmi.freqs <- data.frame (bmi.freqs)
bmi.freqs$levels <- factor (bmi.freqs$levels, levels = c ("normal", "overweight", "obese"))
abs <- ggplot (bmi.freqs, aes (levels, color = levels,fill = levels,count )) + geom_bar(stat = "identity", width = 0.5)  + scale_y_continuous( expand = c(0, 0), limits = c(0,400)) + ggtitle ("Absolute Frequency")+ theme_igray() + theme (legend.position = "none")+ ylab ("") + xlab("")
rel <- ggplot (bmi.freqs, aes (levels, color = levels,fill = levels,rel )) + geom_bar(stat = "identity", width = 0.5) + scale_y_continuous( expand = c(0, 0), limits = c(0,.9)) + ggtitle ("Relative Frequency") + theme_igray()+ theme (legend.position = "none")+ ylab ("") + xlab("")
cum <- ggplot (bmi.freqs, aes (count)) + stat_ecdf() + ylab ("Cumulative Frequency") + xlab ("Levels") + geom_point (aes(x=count, y = cum, color = levels)) + ggtitle ("Cumulative Frequency") + theme_igray()+ theme (legend.position = "none") + ylab ("") + xlab("")
blank <- ggplot()
grid.arrange (abs, rel, cum, nrow = 3, heights = c(1,1,1))
#Summarizing Continuous Variables with two major types of measures
###1) center/location statistics -- measures of the center of the data
##mean
mean(Pima.te$bmi)
##median
median(Pima.te$bmi)
##mode
## R does not have a mode function so lets create one and call it findmode.
findmode <- function(v) {
ux <-unique(v)
ux[which.max(tabulate(match(v, ux)))]
}
findmode(Pima.te$bmi)
### Visualize
ggplot(Pima.te, aes(x=bmi)) +
geom_density(aes(x = bmi, y=..count..), colour="lightskyblue", fill="lightskyblue", alpha = 0.5) + theme_igray() + xlab("BMI") +
scale_y_continuous (expand = c(0,0))+
geom_vline(aes(xintercept=mean(bmi, na.rm=T)),
color="red3", linetype="solid", size=1)  +
geom_vline(aes(xintercept=median(bmi, na.rm=T)),
color="navy", linetype="dashed", size=1)+
geom_vline(aes(xintercept=findmode(bmi)),
color="green3", linetype="dashed", size=1)
##quantiles
##Quantiles are cutpoints that divide the observations in a sample in the same way. There is one less quantile than the number of groups created.
bmi_quants <- quantile (Pima.te$bmi, type = 4)
bmi_quants
###One advantage of dividing our data into quartiles is the we can calculate the interquartile range (IQR) . The IQR is the difference between the upper (Q3) and lower quartile (Q1) and it is also called the midspread or middle fifty → IQR = Q3 − Q1
###[more-info]The IQR for our example data set is:
print ("The IQR for the BMI is")
IQR(Pima.te$bmi)
index <- seq (1:nrow(Pima.te))
Pima.te2 <- cbind (Pima.te, index)
first <- data.frame (subset(Pima.te, bmi <=28.1))
ggplot(Pima.te2, aes(x=index, y = bmi, size = bmi)) + geom_point(color = "orange", alpha = 0.5) + theme_igray() + xlab ("") + ylab ("") +
geom_hline (yintercept = 28.1, color = "navy",linetype ="dashed") + geom_hline (yintercept = 32.9,color = "red",linetype ="dashed") + geom_hline (yintercept = 37.2,color = "red3",linetype ="dashed") +
ggtitle ("BMI Values at each Quartile")
###2) dispersion/spread -- measures of the spread of the data - [provides information about the variability of the data]
##range: the difference between the maximum and minimum observed values: that is, range(x)=maximum(x)−minimum(x). Note that the range is a single value.
##variance: the average of squared deviations from the mean. It cannot be negative.
##standard deviation:  the square root of the variance.The standard deviation may be regarded as the average deviation from the mean. If all observed values are similar, the standard deviation (and variance) will be lower than if the values are more spread out.
##interquartile range
ranges <- c (max(Pima.te$age)-min(Pima.te$age),max(Pima.te$bmi)-min(Pima.te$bmi) )
vars <- c (var(Pima.te$age), var(Pima.te$bmi))
sds <- c (sd(Pima.te$age), sd(Pima.te$bmi))
iqrs <- c (IQR(Pima.te$age), IQR(Pima.te$bmi))
disp <- rbind.data.frame (vars, sds, iqrs, ranges)
colnames (disp) <- c ("AGE", "BMI")
rownames (disp) <- c ("Variance", "Standard Deviation", "IQR", "Range")
disp
####Since it is a categorical/factor variable, we can see how many times each value actually occurs in the data.
table(Pima.te$type)
### R has functions for getting all of the descriptive summary data
summary(Pima.te)
###Tools to learn R on your own
install.packages("ggplot2")
head(Pima.te)
Pima.te
library(plotly)
p <- plot_ly(
x = c("giraffes", "orangutans", "monkeys"),
y = c(20, 14, 23),
name = "SF Zoo",
type = "bar")
p
#grouped boxplots with error bars
myData <- aggregate(mtcars$mpg,
by = list(cyl = mtcars$cyl, gears = mtcars$gear),
FUN = function(x) c(mean = mean(x), sd = sd(x),
n = length(x)))
myData <- do.call(data.frame, myData)
myData$se <- myData$x.sd / sqrt(myData$x.n)
colnames(myData) <- c("cyl", "gears", "mean", "sd", "n", "se")
myData$names <- c(paste(myData$cyl, "cyl /",
myData$gears, " gear"))
head(myData)
source("https://bioconductor.org/biocLite.R")
biocLite("KEGGREST")
library(KEGGREST)
get.kegg.byId(K01369)
install.packages("RbioRXN")
install.packages("fmcsR")
library("RbioRXN")
source("https://bioconductor.org/biocLite.R")
biocLite("fmcsR")
install.packages("RbioRXN")
library("RbioRXN")
get.kegg.byId(K01369)
?get.kegg.byId
get.kegg.byId("KO1369")
get.kegg.byId("R00001")
install.packages("MetaboX")
biocLite("MetaboX")
library(mmnet)
library(biom)
show(mmnet.abund)
data(anno)
summary(anno)
mmnet.abund <- estimateAbundance(anno)
show(mmnet.abund)
loadMetabolicData()
summary(RefDbcache)
ssn <- constructSSN(mmnet.abund)
ssn
head(mmnet.abund)
g <- ssn[[1]]
summary(g)
abund <- get.vertex.attribute(g, "abundance", index = V(g))
summary(abund)
topo.net <- topologicalAnalyzeNet(g)
state <- c("obese", "lean")
differential.net <- differentialAnalyzeNet(ssn, sample.state = state,
method = "OR", cutoff = c(0.5, 2))
summary(differential.net)
showMetagenomicNet(g, mode = "ssn", vertex.label = NA,
edge.width = 0.3, edge.arrow.size = 0.1, edge.arrow.width = 0.1,
layout = layout.fruchterman.reingold)
showMetagenomicNet(g, mode = "ssn", vertex.label = NA,
edge.width = 0.3, edge.arrow.size = 0.1, edge.arrow.width = 0.1,
layout = layout.fruchterman.reingold)
library(devtools)
install_github("zdk123/SpiecEasi",force=TRUE)
install.packages("phyloseq")
source('http://bioconductor.org/biocLite.R')
biocLite('phyloseq')
install_github("zdk123/SpiecEasi",force=TRUE)
library(SpiecEasi)
library(phyloseq)
load('phydata.RRara')
getwd()
load('~/Downloads/phydata.RRara')
load('~/Downloads/phydata.RData')
nc <- 2
icov.select.params=list(rep.num=20, ncores=nc))
se.amgut.ctl <- spiec.easi(amgut.ctl, method='mb', lambda.min.ration=1e-2, nlambda=20, icov.select.params=list(rep.num=20, ncores=nc))
se.amgut.ctl <- spiec.easi(amgut.ctl, method='mb', lambda.min.ratio=1e-2, nlambda=20, icov.select.params=list(rep.num=20, ncores=nc))
se.amgut.ibd <- spiec.easi(amgut.ibd, method='mb', lambda.min.ratio=1e-2, nlambda=20, icov.select.params=list(rep.num=20, ncores=nc))
se.amgut.ctl
class(se.amgut.ctl)
se.amgut.ctl
type(se.amgut.ctl)
class()
se.amgut.ctl
mlow <- read.csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data/ko_low.csv")
head(mlow)
library(mmnet)
library(biom)
setwd("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Infla_cazy/data/")
mlow <- read.csv("/KO_ctl_count.csv")
mlow <- read.csv("KO_ctl_count.csv")
KO <- mlow$State
abundance <- mlow$Ctl
abundance <- as.data.frame(abundance)
KO <- as.data.frame(KO)
biom.data <- make_biom(abundance, observation_metadata = KO)
biom.data$type <- "enzymatic genes abundance"
head(mlow)
head(abundance)
head(KO)
biom.data <- make_biom(abundance, observation_metadata = KO)
library(mmnet)
library(biom)
IMGFile <- system.file("extdata/IMGSample.tab", package = "mmnet")
IMGSample <- read.delim2(IMGFile, quote = "")
## Create BIOM file for network construction
abundance <- IMGSample$Gene.Count
abundance <- abundance/sum(abundance)
abundance <- as.data.frame(abundance)
KO <- IMGSample$KO.ID
KO <- as.data.frame(gsub("KO:", "", KO))
biom.data <- make_biom(abundance, observation_metadata = KO)
biom.data$type <- "enzymatic genes abundance"
library(mmnet)
data(anno)
summary(anno)
## Load the IMG/M sample data
IMGFile <- system.file("extdata/IMGSample.tab", package = "mmnet")
IMGSample <- read.delim2(IMGFile, quote = "")
## Create BIOM file for network construction
abundance <- IMGSample$Gene.Count
abundance <- abundance/sum(abundance)
abundance <- as.data.frame(abundance)
KO <- IMGSample$KO.ID
KO <- as.data.frame(gsub("KO:", "", KO))
biom.data <- make_biom(abundance, observation_metadata = KO)
library(mmnet)
library(biom)
###read in file
mlow <- read.csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data/ko_low.csv")
mhigh <- read.csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data/ko_high.csv")
##
KO <- mlow$ko
abundance <- mlow$Low
abundance <- as.data.frame(abundance)
KO <- as.data.frame(KO)
biom.data <- make_biom(abundance, observation_metadata = KO)
biom.data$type <- "enzymatic genes abundance"
library(biom)
biom.data <- make_biom(abundance, observation_metadata = KO)
biom.data$type <- "enzymatic genes abundance"
library(mmnet)
library(biom)
biocLite("mmnet")
source("https://bioconductor.org/biocLite.R")
biocLite("mmnet")
?make_biom
?make_biom
make_biom
biom.data <- make_biom(abundance, observation_metadata = KO)
biom.data$type <- "enzymatic genes abundance"
library(ggplot2)
df = read_csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data2/OR_net_joined10052016.csv")
df = read.csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data2/OR_net_joined10052016.csv")
head(df)
str(df)
df = read.csv("/Users/leahguthrie/Documents/2016/Labnotebook/Projects/Gutmicrobes_sig_CPT11_metabo/EMP2015/data/NetA/OR2topo_101316.csv")
head(df)
ggplot(df, aes(x=factor(Centrality.Tier), y=BetweennessCentrality colour=OR.type, group=OR.type)) + geom_line()
ggplot(df, aes(x=Centrality.Tier, y=BetweennessCentrality colour=OR.type, group=OR.type)) + geom_line()
ggplot(df, aes(x=Centrality.Tier, y=BetweennessCentrality, colour=OR.type, group=OR.type)) + geom_line()
str(df)
